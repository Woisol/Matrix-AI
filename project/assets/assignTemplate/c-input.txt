leetcode_regex:
(?=^输入：|^输出：|^解释：|^示例 \d：|^提示：|^进阶：)|(?<=^输入：|^输出：|^解释：|^示例 \d：|^提示：|^进阶：)

@section-1 C++字符串

C++字符串
---
# 要求
输入一个字符串，返回其长度
---
#include<iostream>
using namespace std;
int main(){
  return 0;
}
---
a|abc|57bb8b0aec7c4c42b330310ab1b7dbc0
---
1|3

@section-1.1 测试样例换行测试

测试样例换行测试
---
# 要求
输入换行的两个数字，返回它们的和
---
#include<iostream>
using namespace std;
int main(){
  return 0;
}
---
1
2|1
3
---
3|4

@section-2 两数之和

两数之和
---
[力扣原题](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target`  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

> **输入：** nums = [2,7,11,15], target = 9\
> **输出：** [0,1]\
> **解释：** 因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

**示例 2：**

> **输入：** nums = [3,2,4], target = 6\
> **输出：** [1,2]

**示例 3：**

> **输入：** nums = [3,3], target = 6\
> **输出：** [0,1]

**提示：**

* `2 <= nums.length <= 104`
* `-109 <= nums[i] <= 109`
* `-109 <= target <= 109`
* **只会存在一个有效答案**


**进阶：** 你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？
---
#include <iostream>
#include <vector>
#include <sstream>
using namespace std;
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

    }
};

int main() {
    Solution solution;

    vector<int> nums;
    string line;
    getline(cin, line);

    istringstream iss(line);
    int num;
    while (iss >> num) {
        nums.push_back(num);
    }

    int target;
    cin >> target;
    vector<int> result = solution.twoSum(nums, target);
    if (!result.empty()) {
        cout << result[0] << " " << result[1] << endl;
    } else {
        cout << "No solution found" << endl;
    }

    return 0;
}
---
2 7 11 15
9|3 2 4
6|3 3
6
---
0 1|1 2|0 1



@section-3 回文数

回文数
---
[力扣原题](https://leetcode.cn/problems/palindrome-number/)

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

**回文数**是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

* 例如，`121` 是回文，而 `123` 不是。


**示例 1：**

> **输入：** x = 121\
> **输出：** true

**示例 2：**

> **输入：** x = -121\
> **输出：** false\
> **解释：** 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

**示例 3：**

> **输入：** x = 10\
> **输出：** false\
> **解释：** 从右向左读, 为 01 。因此它不是一个回文数。

**提示：**

* `-231 <= x <= 231 - 1`


**进阶：** 你能不将整数转为字符串来解决这个问题吗？
---
#include <iostream>
using namespace std;
class Solution {
public:
    bool isPalindrome(int x) {

    }
};

int main() {
    Solution solution;
    int x;
    cin >> x;
    bool result = solution.isPalindrome(x);
    cout << (result ? "true" : "false") << endl;
    return 0;
}
---
121|123|10
---
true|false|false

@section-4 整数反转

整数反转
---
[力扣原题](https://leetcode.cn/problems/reverse-integer/description/)

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231,  231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例 1：**

> **输入：** x = 123\
> **输出：** 321

**示例 2：**

> **输入：** x = -123\
> **输出：** -321

**示例 3：**

> **输入：** x = 120\
> **输出：** 21

**示例 4：**

> **输入：** x = 0\
> **输出：** 0


**提示：**

* `-231 <= x <= 231 - 1`
---
#include<iostream>
using namespace std;
class Solution {
public:
    int reverse(int x) {

    }
};

int main(){
    Solution solution;
    int x;
    cin >> x;
    int result = solution.reverse(x);
    cout << result << endl;
    return 0;
}
---
123|-123|120|0
---
321|-321|21|0

@section-5 有效括号

有效括号
---
[力扣原题](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。


**示例 1：**

> **输入：** s = "()"\
> **输出：** true

**示例 2：**

> **输入：** s = "()[]{}"\
> **输出：** true

**示例 3：**

> **输入：** s = "(]"\
> **输出：** false

**示例 4：**

> **输入：** s = "([])"\
> **输出：** true

**示例 5：**

> **输入：** s = "([)]"\
> **输出：** false



**提示：**

* `1 <= s.length <= 104`
* `s` 仅由括号 `'()[]{}'` 组成
---
#include <iostream>
#include <stack>
#include <unordered_map>

using namespace std;
class Solution {
public:
    bool isValid(string s) {

    }
};

int main() {
    Solution solution;
    string s;
    cin >> s;
    bool result = solution.isValid(s);
    cout << (result ? "true" : "false") << endl;
    return 0;
}
---
()|()[]{}|(]|([])|([)]|([()[[[}]{(]{(})}]])|([([])[](){}]{{[]()}}){([]){}({()}{})[]}
---
true|true|false|true|false|false|true

@section-6 排序链表

排序链表
---
[力扣原题](https://leetcode.cn/problems/sort-list/description/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

> **输入：** 4 2 1 3\
> **输出：** 1 2 3 4

**示例 2：**

> **输入：** -1 5 3 4 0\
> **输出：** -1 0 3 4 5

**示例 3：**

> **输入：**\
> **输出：**

**提示：**

* 链表中节点的数目在范围 `[0, 5 * 104]` 内
* `-105 <= Node.val <= 105`


**进阶**：你可以在` O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
---
#include<iostream>
#include<vector>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* sortList(ListNode* head) {

    }
};

// 辅助函数：根据数组创建链表
ListNode* createList(const vector<int>& nums) {
    if (nums.empty()) return nullptr;

    ListNode* head = new ListNode(nums[0]);
    ListNode* current = head;

    for (int i = 1; i < nums.size(); i++) {
        current->next = new ListNode(nums[i]);
        current = current->next;
    }

    return head;
}

// 辅助函数：打印链表
void printList(ListNode* head) {
    while (head != nullptr) {
        cout << head->val;
        if (head->next != nullptr) {
            cout << " ";
        }
        head = head->next;
    }
    cout << endl;
}

// 辅助函数：释放链表内存
void freeList(ListNode* head) {
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
}

int main() {
    Solution solution;

    vector<int> nums;
    string line;
    getline(cin, line);

    // 解析输入的数字
    if (!line.empty()) {
        size_t pos = 0;
        while (pos < line.length()) {
            // 跳过空格
            while (pos < line.length() && isspace(line[pos])) {
                pos++;
            }

            if (pos < line.length()) {
                // 找数字的结束位置
                size_t start = pos;
                while (pos < line.length() && !isspace(line[pos])) {
                    pos++;
                }

                // 转换为数字
                string numStr = line.substr(start, pos - start);
                try {
                    int num = stoi(numStr);
                    nums.push_back(num);
                } catch (const exception& e) {
                    cout << "无效数字: " << numStr << endl;
                }
            }
        }
    }

    if (nums.empty()) {
        cout << "输入为空，程序结束。" << endl;
        return 0;
    }

    // 创建链表
    ListNode* head = createList(nums);

    // 打印原链表
    // printList(head);

    // 排序
    ListNode* sortedHead = solution.sortList(head);

    // 打印排序后的链表
    printList(sortedHead);

    // 释放内存
    freeList(sortedHead);

    return 0;
}
---
4 2 1 3|-1 5 3 4 0
---
1 2 3 4|-1 0 3 4 5

<!-- @section-7 合并两个有序数组

合并两个有序数组
---
[力扣原题](https://leetcode.cn/problems/merge-sorted-array/)

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：** 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` `中。为了应对这种情况，nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例 1：**

> **输入：** nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\
> **输出：** [1,2,2,3,5,6]\
> **解释：** 需要合并 [1,2,3] 和 [2,5,6] 。\
> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

**示例 2：**

> **输入：** nums1 = [1], m = 1, nums2 = [], n = 0\
> **输出：** [1]\
> **解释：** 需要合并 [1] 和 [] 。\
> 合并结果是 [1] 。

**示例 3：**

> **输入：** nums1 = [0], m = 0, nums2 = [1], n = 1\
> **输出：** [1]\
> **解释：** 需要合并的数组是 [] 和 [1] 。\
> 合并结果是 [1] 。\
> 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

**提示：**

* `nums1.length == m + n`
* `nums2.length == n`
* `0 <= m, n <= 200`
* `1 <= m + n <= 200`
* `-109 <= nums1[i], nums2[j] <= 109`

**进阶：** 你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？
--- -->