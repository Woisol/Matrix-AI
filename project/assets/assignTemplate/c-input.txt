@section-code1

C++字符串
---
# 要求
输入一个字符串，返回其长度
---
#include<iostream>
using namespace std;
int main(){
  return 0;
}
---
a|abc
---
1|3

@section-code2

回文数
---
给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

**回文数**是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

* 例如，`121` 是回文，而 `123` 不是。


**示例 1：**

> **输入：**x = 121
  **输出：**true

**示例 2：**

> **输入：**x = -121
  **输出：**false
  **解释：**从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

**示例 3：**

> **输入：**x = 10
  **输出：**false
  **解释：**从右向左读, 为 01 。因此它不是一个回文数。


**提示：**

* `-231 <= x <= 231 - 1`


**进阶：**你能不将整数转为字符串来解决这个问题吗？
---
#include <iostream>
using namespace std;
class Solution {
public:
    bool isPalindrome(int x) {

    }
};

int main() {
    Solution solution;
    int x;
    cin >> x;
    bool result = solution.isPalindrome(x);
    cout << (result ? "true" : "false") << endl;
    return 0;
}
---
121|123|10
---
true|false|false

@section-code3

排序链表
---
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。
**示例 1：**

> 输入：4,2,1,3
  输出：1,2,3,4
**示例 2：**

> 输入：-1,5,3,4,0
  输出：-1,0,3,4,5
**示例 3：**

> 输入：
  输出：


**提示：**

* 链表中节点的数目在范围 `[0, 5 * 104]` 内
* `-105 <= Node.val <= 105`


**进阶**：你可以在` O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
---
#include<iostream>
#include<vector>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* sortList(ListNode* head) {

    }
};

// 辅助函数：根据数组创建链表
ListNode* createList(const vector<int>& nums) {
    if (nums.empty()) return nullptr;

    ListNode* head = new ListNode(nums[0]);
    ListNode* current = head;

    for (int i = 1; i < nums.size(); i++) {
        current->next = new ListNode(nums[i]);
        current = current->next;
    }

    return head;
}

// 辅助函数：打印链表
void printList(ListNode* head) {
    while (head != nullptr) {
        cout << head->val;
        if (head->next != nullptr) {
            cout << " ";
        }
        head = head->next;
    }
    cout << endl;
}

// 辅助函数：释放链表内存
void freeList(ListNode* head) {
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
}

int main() {
    Solution solution;

    vector<int> nums;
    string line;
    getline(cin, line);

    // 解析输入的数字
    if (!line.empty()) {
        size_t pos = 0;
        while (pos < line.length()) {
            // 跳过空格
            while (pos < line.length() && isspace(line[pos])) {
                pos++;
            }

            if (pos < line.length()) {
                // 找数字的结束位置
                size_t start = pos;
                while (pos < line.length() && !isspace(line[pos])) {
                    pos++;
                }

                // 转换为数字
                string numStr = line.substr(start, pos - start);
                try {
                    int num = stoi(numStr);
                    nums.push_back(num);
                } catch (const exception& e) {
                    cout << "无效数字: " << numStr << endl;
                }
            }
        }
    }

    if (nums.empty()) {
        cout << "输入为空，程序结束。" << endl;
        return 0;
    }

    // 创建链表
    ListNode* head = createList(nums);

    // 打印原链表
    // printList(head);

    // 排序
    ListNode* sortedHead = solution.sortList(head);

    // 打印排序后的链表
    printList(sortedHead);

    // 释放内存
    freeList(sortedHead);

    return 0;
}
---
4 2 1 3|-1 5 3 4 0|
---
1 2 3 4|-1 0 3 4 5|

@section-code4